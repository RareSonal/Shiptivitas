{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\91848\\\\Desktop\\\\cloudsecdoc\\\\interviewPrep\\\\Simulations\\\\YCombinator-React-advanced\\\\Shiptivitas\\\\frontend\\\\src\\\\Board.js\";\nimport React, { Component } from 'react';\nimport 'dragula/dist/dragula.css';\nimport Swimlane from './Swimlane';\nimport './Board.css';\nimport dragula from 'dragula';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst statusToKey = {\n  'backlog': 'backlog',\n  'in-progress': 'inProgress',\n  'complete': 'complete'\n};\n\n/*const keyToStatus = {\r\n  backlog: 'backlog',\r\n  inProgress: 'in-progress',\r\n  complete: 'complete',\r\n};*/\n\nexport default class Board extends Component {\n  constructor(props) {\n    super(props);\n    this.handleDrop = (el, target, source, sibling) => {\n      console.log('Dropped element:', el);\n      console.log('Target:', target);\n      console.log('Sibling:', sibling);\n      this.updateCardStatus(el, target, sibling);\n    };\n    this.state = {\n      cards: this.props.clients || {\n        backlog: [],\n        inProgress: [],\n        complete: []\n      }\n    };\n    this.swimlanes = {\n      backlog: /*#__PURE__*/React.createRef(),\n      inProgress: /*#__PURE__*/React.createRef(),\n      complete: /*#__PURE__*/React.createRef()\n    };\n  }\n  componentDidMount() {\n    this.drake = dragula([this.swimlanes.backlog.current, this.swimlanes.inProgress.current, this.swimlanes.complete.current]);\n\n    // Ensuring that the drag event listener is set after the DOM is updated\n    setTimeout(() => {\n      this.drake.on('drop', this.handleDrop);\n    }, 0);\n  }\n  componentWillUnmount() {\n    if (this.drake) {\n      setTimeout(() => {\n        // Cleanup after React updates the DOM\n        this.drake.off('drop', this.handleDrop);\n        this.drake.destroy();\n      }, 0);\n    }\n  }\n  async updateCardStatus(el, target, sibling) {\n    const cardId = el.dataset.id;\n    const targetStatus = target.dataset.status;\n    const targetKey = statusToKey[targetStatus];\n    const allCards = [...(this.state.cards.backlog || []), ...(this.state.cards.inProgress || []), ...(this.state.cards.complete || [])];\n    const card = allCards.find(c => c.id.toString() === cardId);\n    if (!card) return;\n    const oldStatus = card.status;\n    const oldPriority = card.priority;\n    const siblingId = sibling ? sibling.dataset.id : null;\n    const targetCards = allCards.filter(c => c.status === targetStatus && c.id !== card.id).sort((a, b) => a.priority - b.priority);\n    const newPriority = siblingId ? targetCards.findIndex(c => c.id.toString() === siblingId) : targetCards.length;\n    const updatedLocalCards = allCards.map(c => {\n      if (c.id.toString() === cardId) {\n        return {\n          ...c,\n          status: targetStatus,\n          priority: newPriority\n        };\n      }\n      return c;\n    });\n    const newCardsState = {\n      backlog: [],\n      inProgress: [],\n      complete: []\n    };\n    updatedLocalCards.forEach(c => {\n      const key = statusToKey[c.status];\n      if (key) {\n        newCardsState[key].push(c);\n      } else {\n        console.warn(`Unexpected status: ${c.status}, skipping card.`);\n      }\n    });\n    this.setState({\n      cards: newCardsState\n    });\n    try {\n      const response = await fetch(`/api/v1/cards/${card.id}`, {\n        method: 'PUT',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          newStatus: targetStatus,\n          newPriority,\n          oldStatus,\n          oldPriority,\n          userId: this.props.currentUserId\n        })\n      });\n      if (!response.ok) {\n        console.error('Failed to update card status on server');\n        return;\n      }\n      const updatedCards = await response.json();\n      this.setState({\n        cards: this.updateCardsState(updatedCards)\n      });\n    } catch (error) {\n      console.error('Error updating card:', error);\n    }\n  }\n  updateCardsState(updatedCards) {\n    const newCards = {\n      backlog: [],\n      inProgress: [],\n      complete: []\n    };\n    updatedCards.forEach(card => {\n      const key = statusToKey[card.status];\n      if (key) {\n        newCards[key].push(card);\n      } else {\n        console.warn(`Unexpected status: ${card.status}, skipping card.`);\n      }\n    });\n    return newCards;\n  }\n  getCardStyle(status) {\n    switch (status) {\n      case 'backlog':\n        return {\n          backgroundColor: 'grey'\n        };\n      case 'in-progress':\n        return {\n          backgroundColor: 'blue'\n        };\n      case 'complete':\n        return {\n          backgroundColor: 'green'\n        };\n      default:\n        return {};\n    }\n  }\n  renderSwimlane(name, status, cards, ref) {\n    return /*#__PURE__*/_jsxDEV(Swimlane, {\n      name: name,\n      status: status,\n      clients: cards.map(c => ({\n        ...c,\n        style: this.getCardStyle(c.status)\n      })),\n      dragulaRef: ref\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 172,\n      columnNumber: 7\n    }, this);\n  }\n  render() {\n    const {\n      backlog = [],\n      inProgress = [],\n      complete = []\n    } = this.state.cards;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"Board container-fluid\",\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"row\",\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-md-4\",\n          children: this.renderSwimlane('Backlog', 'backlog', backlog, this.swimlanes.backlog)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 190,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-md-4\",\n          children: this.renderSwimlane('In Progress', 'in-progress', inProgress, this.swimlanes.inProgress)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 193,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"col-md-4\",\n          children: this.renderSwimlane('Complete', 'complete', complete, this.swimlanes.complete)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 196,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 189,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 188,\n      columnNumber: 7\n    }, this);\n  }\n}\n\n/*\r\nimport React, { Component } from 'react';\r\nimport 'dragula/dist/dragula.css';\r\nimport Swimlane from './Swimlane';\r\nimport './Board.css';\r\nimport dragula from 'dragula';\r\n\r\nexport default class Board extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      cards: this.props.clients || { backlog: [], inProgress: [], complete: [] },\r\n    };\r\n    this.swimlanes = {\r\n      backlog: React.createRef(),\r\n      inProgress: React.createRef(),\r\n      complete: React.createRef(),\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.drake = dragula([\r\n      this.swimlanes.backlog.current,\r\n      this.swimlanes.inProgress.current,\r\n      this.swimlanes.complete.current,\r\n    ]);\r\n\r\n    this.drake.on('drop', (el, target, source, sibling) => {\r\n      console.log('Card dropped:', el.dataset.id, target.dataset.status); // Debugging\r\n      this.updateCardStatus(el, target, sibling);\r\n    });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.drake) {\r\n      this.drake.destroy();\r\n    }\r\n  }\r\n\r\n  // Update card status and priority after drag\r\n  async updateCardStatus(el, target, sibling) {\r\n    const cardId = el.dataset.id;\r\n    const targetStatus = target.dataset.status;\r\n\r\n    // Fetch all cards and find the dragged card\r\n    const allCards = [\r\n      ...(this.state.cards.backlog || []),\r\n      ...(this.state.cards.inProgress || []),\r\n      ...(this.state.cards.complete || []),\r\n    ];\r\n    const card = allCards.find(c => c.id.toString() === cardId);\r\n\r\n    if (!card) return;\r\n\r\n    const oldStatus = card.status;\r\n    const oldPriority = card.priority;\r\n\r\n    // Find the new priority based on the sibling card's position\r\n    const siblingId = sibling ? sibling.dataset.id : null;\r\n    const targetCards = allCards\r\n      .filter(c => c.status === targetStatus && c.id !== card.id)\r\n      .sort((a, b) => a.priority - b.priority);\r\n\r\n    const newPriority = siblingId\r\n      ? targetCards.findIndex(c => c.id.toString() === siblingId)\r\n      : targetCards.length;\r\n\r\n    try {\r\n      console.log(`Updating card status for card ID: ${cardId}, from ${oldStatus} to ${targetStatus}`);\r\n\r\n      // Update the card status and priority via API\r\n      const response = await fetch(`/api/v1/cards/${card.id}`, {\r\n        method: 'PUT',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          newStatus: targetStatus,\r\n          newPriority,\r\n          oldStatus,\r\n          oldPriority,\r\n          userId: this.props.currentUserId,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        console.error('Failed to update card status');\r\n        return;\r\n      }\r\n\r\n      const updatedCards = await response.json();\r\n\r\n      // Update the state with the updated cards\r\n      this.setState({ cards: this.updateCardsState(updatedCards) });\r\n      console.log('Card status updated:', updatedCards);\r\n\r\n    } catch (error) {\r\n      console.error('Error updating card:', error);\r\n    }\r\n  }\r\n\r\n  // Helper function to update cards state\r\n  updateCardsState(updatedCards) {\r\n    const newCards = {\r\n      backlog: [],\r\n      inProgress: [],\r\n      complete: [],\r\n    };\r\n\r\n    updatedCards.forEach(card => {\r\n      // Ensure the status is a valid category before attempting to push\r\n      if (['backlog', 'in-progress', 'complete'].includes(card.status)) {\r\n        newCards[card.status].push(card);\r\n      } else {\r\n        // Log unexpected statuses and handle them gracefully\r\n        console.warn(`Unexpected status: ${card.status}, skipping card.`);\r\n      }\r\n    });\r\n\r\n    return newCards;\r\n  }\r\n\r\n  // Determine the card style based on its status\r\n  getCardStyle(status) {\r\n    switch (status) {\r\n      case 'backlog': return { backgroundColor: 'grey' };\r\n      case 'in-progress': return { backgroundColor: 'blue' };\r\n      case 'complete': return { backgroundColor: 'green' };\r\n      default: return {};\r\n    }\r\n  }\r\n\r\n  // Render a Swimlane component for each status category\r\n  renderSwimlane(name, status, cards, ref) {\r\n    return (\r\n      <Swimlane\r\n        name={name}\r\n        status={status}\r\n        clients={cards.map(c => ({\r\n          ...c,\r\n          style: this.getCardStyle(c.status), // Recalculate style after status change\r\n        }))}\r\n        dragulaRef={ref}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { backlog = [], inProgress = [], complete = [] } = this.state.cards;\r\n\r\n    return (\r\n      <div className=\"Board container-fluid\">\r\n        <div className=\"row\">\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Backlog', 'backlog', backlog, this.swimlanes.backlog)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('In Progress', 'in-progress', inProgress, this.swimlanes.inProgress)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Complete', 'complete', complete, this.swimlanes.complete)}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n*/","map":{"version":3,"names":["React","Component","Swimlane","dragula","jsxDEV","_jsxDEV","statusToKey","Board","constructor","props","handleDrop","el","target","source","sibling","console","log","updateCardStatus","state","cards","clients","backlog","inProgress","complete","swimlanes","createRef","componentDidMount","drake","current","setTimeout","on","componentWillUnmount","off","destroy","cardId","dataset","id","targetStatus","status","targetKey","allCards","card","find","c","toString","oldStatus","oldPriority","priority","siblingId","targetCards","filter","sort","a","b","newPriority","findIndex","length","updatedLocalCards","map","newCardsState","forEach","key","push","warn","setState","response","fetch","method","headers","body","JSON","stringify","newStatus","userId","currentUserId","ok","error","updatedCards","json","updateCardsState","newCards","getCardStyle","backgroundColor","renderSwimlane","name","ref","style","dragulaRef","fileName","_jsxFileName","lineNumber","columnNumber","render","className","children"],"sources":["C:/Users/91848/Desktop/cloudsecdoc/interviewPrep/Simulations/YCombinator-React-advanced/Shiptivitas/frontend/src/Board.js"],"sourcesContent":["import React, { Component } from 'react';\r\nimport 'dragula/dist/dragula.css';\r\nimport Swimlane from './Swimlane';\r\nimport './Board.css';\r\nimport dragula from 'dragula';\r\n\r\nconst statusToKey = {\r\n  'backlog': 'backlog',\r\n  'in-progress': 'inProgress',\r\n  'complete': 'complete',\r\n};\r\n\r\n/*const keyToStatus = {\r\n  backlog: 'backlog',\r\n  inProgress: 'in-progress',\r\n  complete: 'complete',\r\n};*/\r\n\r\nexport default class Board extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      cards: this.props.clients || { backlog: [], inProgress: [], complete: [] },\r\n    };\r\n    this.swimlanes = {\r\n      backlog: React.createRef(),\r\n      inProgress: React.createRef(),\r\n      complete: React.createRef(),\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.drake = dragula([\r\n      this.swimlanes.backlog.current,\r\n      this.swimlanes.inProgress.current,\r\n      this.swimlanes.complete.current,\r\n    ]);\r\n\r\n    // Ensuring that the drag event listener is set after the DOM is updated\r\n    setTimeout(() => {\r\n      this.drake.on('drop', this.handleDrop);\r\n    }, 0);\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.drake) {\r\n      setTimeout(() => {\r\n        // Cleanup after React updates the DOM\r\n        this.drake.off('drop', this.handleDrop);\r\n        this.drake.destroy();\r\n      }, 0);\r\n    }\r\n  }\r\n\r\n  handleDrop = (el, target, source, sibling) => {\r\n    console.log('Dropped element:', el);\r\n    console.log('Target:', target);\r\n    console.log('Sibling:', sibling);\r\n    this.updateCardStatus(el, target, sibling);\r\n  };\r\n\r\n  async updateCardStatus(el, target, sibling) {\r\n    const cardId = el.dataset.id;\r\n    const targetStatus = target.dataset.status;\r\n    const targetKey = statusToKey[targetStatus];\r\n\r\n    const allCards = [\r\n      ...(this.state.cards.backlog || []),\r\n      ...(this.state.cards.inProgress || []),\r\n      ...(this.state.cards.complete || []),\r\n    ];\r\n\r\n    const card = allCards.find(c => c.id.toString() === cardId);\r\n    if (!card) return;\r\n\r\n    const oldStatus = card.status;\r\n    const oldPriority = card.priority;\r\n\r\n    const siblingId = sibling ? sibling.dataset.id : null;\r\n    const targetCards = allCards\r\n      .filter(c => c.status === targetStatus && c.id !== card.id)\r\n      .sort((a, b) => a.priority - b.priority);\r\n\r\n    const newPriority = siblingId\r\n      ? targetCards.findIndex(c => c.id.toString() === siblingId)\r\n      : targetCards.length;\r\n\r\n    const updatedLocalCards = allCards.map(c => {\r\n      if (c.id.toString() === cardId) {\r\n        return {\r\n          ...c,\r\n          status: targetStatus,\r\n          priority: newPriority,\r\n        };\r\n      }\r\n      return c;\r\n    });\r\n\r\n    const newCardsState = {\r\n      backlog: [],\r\n      inProgress: [],\r\n      complete: [],\r\n    };\r\n\r\n    updatedLocalCards.forEach(c => {\r\n      const key = statusToKey[c.status];\r\n      if (key) {\r\n        newCardsState[key].push(c);\r\n      } else {\r\n        console.warn(`Unexpected status: ${c.status}, skipping card.`);\r\n      }\r\n    });\r\n\r\n    this.setState({ cards: newCardsState });\r\n\r\n    try {\r\n      const response = await fetch(`/api/v1/cards/${card.id}`, {\r\n        method: 'PUT',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          newStatus: targetStatus,\r\n          newPriority,\r\n          oldStatus,\r\n          oldPriority,\r\n          userId: this.props.currentUserId,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        console.error('Failed to update card status on server');\r\n        return;\r\n      }\r\n\r\n      const updatedCards = await response.json();\r\n      this.setState({ cards: this.updateCardsState(updatedCards) });\r\n\r\n    } catch (error) {\r\n      console.error('Error updating card:', error);\r\n    }\r\n  }\r\n\r\n  updateCardsState(updatedCards) {\r\n    const newCards = {\r\n      backlog: [],\r\n      inProgress: [],\r\n      complete: [],\r\n    };\r\n\r\n    updatedCards.forEach(card => {\r\n      const key = statusToKey[card.status];\r\n      if (key) {\r\n        newCards[key].push(card);\r\n      } else {\r\n        console.warn(`Unexpected status: ${card.status}, skipping card.`);\r\n      }\r\n    });\r\n\r\n    return newCards;\r\n  }\r\n\r\n  getCardStyle(status) {\r\n    switch (status) {\r\n      case 'backlog': return { backgroundColor: 'grey' };\r\n      case 'in-progress': return { backgroundColor: 'blue' };\r\n      case 'complete': return { backgroundColor: 'green' };\r\n      default: return {};\r\n    }\r\n  }\r\n\r\n  renderSwimlane(name, status, cards, ref) {\r\n    return (\r\n      <Swimlane\r\n        name={name}\r\n        status={status}\r\n        clients={cards.map(c => ({\r\n          ...c,\r\n          style: this.getCardStyle(c.status),\r\n        }))}\r\n        dragulaRef={ref}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { backlog = [], inProgress = [], complete = [] } = this.state.cards;\r\n\r\n    return (\r\n      <div className=\"Board container-fluid\">\r\n        <div className=\"row\">\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Backlog', 'backlog', backlog, this.swimlanes.backlog)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('In Progress', 'in-progress', inProgress, this.swimlanes.inProgress)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Complete', 'complete', complete, this.swimlanes.complete)}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n/*\r\nimport React, { Component } from 'react';\r\nimport 'dragula/dist/dragula.css';\r\nimport Swimlane from './Swimlane';\r\nimport './Board.css';\r\nimport dragula from 'dragula';\r\n\r\nexport default class Board extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      cards: this.props.clients || { backlog: [], inProgress: [], complete: [] },\r\n    };\r\n    this.swimlanes = {\r\n      backlog: React.createRef(),\r\n      inProgress: React.createRef(),\r\n      complete: React.createRef(),\r\n    };\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.drake = dragula([\r\n      this.swimlanes.backlog.current,\r\n      this.swimlanes.inProgress.current,\r\n      this.swimlanes.complete.current,\r\n    ]);\r\n\r\n    this.drake.on('drop', (el, target, source, sibling) => {\r\n      console.log('Card dropped:', el.dataset.id, target.dataset.status); // Debugging\r\n      this.updateCardStatus(el, target, sibling);\r\n    });\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    if (this.drake) {\r\n      this.drake.destroy();\r\n    }\r\n  }\r\n\r\n  // Update card status and priority after drag\r\n  async updateCardStatus(el, target, sibling) {\r\n    const cardId = el.dataset.id;\r\n    const targetStatus = target.dataset.status;\r\n\r\n    // Fetch all cards and find the dragged card\r\n    const allCards = [\r\n      ...(this.state.cards.backlog || []),\r\n      ...(this.state.cards.inProgress || []),\r\n      ...(this.state.cards.complete || []),\r\n    ];\r\n    const card = allCards.find(c => c.id.toString() === cardId);\r\n\r\n    if (!card) return;\r\n\r\n    const oldStatus = card.status;\r\n    const oldPriority = card.priority;\r\n\r\n    // Find the new priority based on the sibling card's position\r\n    const siblingId = sibling ? sibling.dataset.id : null;\r\n    const targetCards = allCards\r\n      .filter(c => c.status === targetStatus && c.id !== card.id)\r\n      .sort((a, b) => a.priority - b.priority);\r\n\r\n    const newPriority = siblingId\r\n      ? targetCards.findIndex(c => c.id.toString() === siblingId)\r\n      : targetCards.length;\r\n\r\n    try {\r\n      console.log(`Updating card status for card ID: ${cardId}, from ${oldStatus} to ${targetStatus}`);\r\n\r\n      // Update the card status and priority via API\r\n      const response = await fetch(`/api/v1/cards/${card.id}`, {\r\n        method: 'PUT',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({\r\n          newStatus: targetStatus,\r\n          newPriority,\r\n          oldStatus,\r\n          oldPriority,\r\n          userId: this.props.currentUserId,\r\n        }),\r\n      });\r\n\r\n      if (!response.ok) {\r\n        console.error('Failed to update card status');\r\n        return;\r\n      }\r\n\r\n      const updatedCards = await response.json();\r\n\r\n      // Update the state with the updated cards\r\n      this.setState({ cards: this.updateCardsState(updatedCards) });\r\n      console.log('Card status updated:', updatedCards);\r\n\r\n    } catch (error) {\r\n      console.error('Error updating card:', error);\r\n    }\r\n  }\r\n\r\n  // Helper function to update cards state\r\n  updateCardsState(updatedCards) {\r\n    const newCards = {\r\n      backlog: [],\r\n      inProgress: [],\r\n      complete: [],\r\n    };\r\n\r\n    updatedCards.forEach(card => {\r\n      // Ensure the status is a valid category before attempting to push\r\n      if (['backlog', 'in-progress', 'complete'].includes(card.status)) {\r\n        newCards[card.status].push(card);\r\n      } else {\r\n        // Log unexpected statuses and handle them gracefully\r\n        console.warn(`Unexpected status: ${card.status}, skipping card.`);\r\n      }\r\n    });\r\n\r\n    return newCards;\r\n  }\r\n\r\n  // Determine the card style based on its status\r\n  getCardStyle(status) {\r\n    switch (status) {\r\n      case 'backlog': return { backgroundColor: 'grey' };\r\n      case 'in-progress': return { backgroundColor: 'blue' };\r\n      case 'complete': return { backgroundColor: 'green' };\r\n      default: return {};\r\n    }\r\n  }\r\n\r\n  // Render a Swimlane component for each status category\r\n  renderSwimlane(name, status, cards, ref) {\r\n    return (\r\n      <Swimlane\r\n        name={name}\r\n        status={status}\r\n        clients={cards.map(c => ({\r\n          ...c,\r\n          style: this.getCardStyle(c.status), // Recalculate style after status change\r\n        }))}\r\n        dragulaRef={ref}\r\n      />\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const { backlog = [], inProgress = [], complete = [] } = this.state.cards;\r\n\r\n    return (\r\n      <div className=\"Board container-fluid\">\r\n        <div className=\"row\">\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Backlog', 'backlog', backlog, this.swimlanes.backlog)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('In Progress', 'in-progress', inProgress, this.swimlanes.inProgress)}\r\n          </div>\r\n          <div className=\"col-md-4\">\r\n            {this.renderSwimlane('Complete', 'complete', complete, this.swimlanes.complete)}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n*/"],"mappings":"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CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}